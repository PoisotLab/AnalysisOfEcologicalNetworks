---
title: Counting species and interactions
nav_order: 1
---

# Counting species and interactions

## Goals of this chapter

## My first network analysis

We will begin this chapter by looking a basic information we can get on a single
network - this is useful both as an exploration of the concepts, and as an
introduction to the ways we can manipulate network data through programming. In
particular, this section will serve as a short introduction to the `Mangal`
package to download ecological networks dataset.

We will need a few packages for this (and indeed most of the following) chapter,
which you have installed during the introduction. First, we will want to load
functions to analyse networks themselves:

```julia
using EcologicalNetworks
```

Next, we will load the `Mangal` package, to get access to a variety of functions
allowing us to get network data from the [mangal.io](http://mangal.io) website.
Note that we will not load it with `using`, but with `import` - this means that
we will need to preface the name of the functions by `Mangal.`, to avoid having
a lot of functions with non-specific names in our namespace:

```julia
import Mangal
```

Finally, because we will want to make some visualisations, we will load the
packages for plots:

```julia
using Plots
import EcologicalNetworksPlots
```

All of these packages have documentations, and it is always a good idea to see
the different options available for the various functions. One way to get a
sense of the functions included in a package, or to get help on these functions,
it to type `?[PackageName].` in the Julia REPL, and to press Tab to see the
possible functions. This is also a great way to discover functionalities in
packages.

### Getting the network data

And with this, we are all set to get our first network:

```julia
first_network = Mangal.network(935)
print(first_network.description)
```

This object has information about a network. Most of these information are
metadata, *i.e.* we do not have the actual interactions at this point. We can
get a list of interactions contained in this network with

```julia
first_network_interactions = Mangal.interactions(first_network);
print("There are $(length(first_network_interactions)) interactions in this network")
```

We can have a deeper look at the first interaction:

```julia
first_interaction = first(first_network_interactions)
```

This has *a lot* of information! We can focus on the most important properties:

| Information           | How to get it                   | Result                            |
| --------------------- | ------------------------------- | --------------------------------- |
| Interaction type      | `first_interaction.type`        | `j first_interaction.type`        |
| Species 1             | `first_interaction.from.name`   | `j first_interaction.from.name`   |
| Species 2 taxon ID    | `first_interaction.to.taxon.id` | `j first_interaction.to.taxon.id` |
| Method of observation | `first_interaction.method`      | `j first_interaction.method`      |
| Interaction strength  | `first_interaction.strength`    | `j first_interaction.strength`    |

### Creating the network object

There are a few ways to collect these interactions into a network, but the
simplest by far is to transform (`convert`) our `MangalNetwork` object into a
`UnipartiteQuantitativeNetwork` (which is used by `EcologicalNetworks`) - this
is done as follows:

```julia
N = convert(UnipartiteQuantitativeNetwork, first_network)
```

At this point, you are hopefuly familiar with what "network" means, but may have
some hesitations about the meaning of "unipartite" and "quantitative". **TK**

As a sidenote, we will often adhere to the following convention when naming
networks. `N` is a unipartite network, `B` is a bipartite network, and `R` is a
random network. This is a useful way to get a sense of what we can expect the
variable to contain.

Speaking of which, we know that this network contains information on
pollination, and pollination networks are bipartite, because they have two
groups of organisms (pollinators and polinized), which we assume do not
establish interactions within the group. We can therefore transform (`convert`)
our network into its bipartite representation:

```julia
B = convert(BipartiteQuantitativeNetwork, N)
```

### Visualizing the network

To get a sense of what the network "looks like", we may decide to plot it. We
have imported the `EcologicalNetworksPlots` package, which comes with a variety
of layouts and other functionalities for this task, and works in conjunction
with `Plots`:

```julia
I = EcologicalNetworksPlots.initial(EcologicalNetworksPlots.RandomInitialLayout, B)
for step in 1:4000
  EcologicalNetworksPlots.position!(EcologicalNetworksPlots.ForceDirectedLayout(2.5), I, B)
end
plot(I, B, aspectratio=1)
scatter!(I, B, bipartite=true, mc=:lightgrey, msc=:white, msw=2, ms=8)
```

We *may* decide to do this, but in practice we will often refrain from plotting
networks. Plotting networks is very rarely useful. Depending on the layout, it
is easy to mis-communicate about the structure of the network. Past a certain
number of species and interactions, the plots look like hairballs. Most
importantly, we have a wide variety of quantitative measures that we can apply,
and they will teach us a lot more about the network structure than any plot ever
would. Plotting is marginally useful during explorations, and to illustrate
certain concepts, but should largely be avoided for research purposes.

### Counting species and interactions

```julia
richness(B)
```

```julia
richness(B; dims=1)
richness(B; dims=2)
```

```julia
links(B)
```

```julia
sum(B)
```

## Link-species relationships

### Overview of the theory

### Getting the data

```julia
small_lakes_dataset = first(Mangal.datasets("q" => "Adirondack"))
small_lakes_networks = Mangal.networks(small_lakes_dataset)
N = convert.(UnipartiteNetwork, small_lakes_networks)
```

```julia
scatter(
  richness.(N),
  links.(N),
  lab="",
  legend=:topleft,
  xlabel = "Species",
  ylabel = "Links",
  frame=:grid,
  xlim=(10,100),
  ylim=(10,1000),
  xscale=:log,
  yscale=:log,
  c=:grey, msw=0, alpha=0.5, ms=6
)
S = 10:100
plot!(S, (S.-1), ls=:dash, c=:black, lab="(S-1)")
plot!(S, 0.086.*(S.^2.0.-(S.-1)).+(S.-1), lab="L", c=:black, ls=:dot)
plot!(S, S.^2.0, c=:black, lab="SÂ²")
```

## Degree and degree distribution
