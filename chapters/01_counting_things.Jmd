---
title: Counting species and interactions
---

## Goals of this chapter

## My first network analysis

We will begin this chapter by looking a basic information we can get on a single
network - this is useful both as an exploration of the concepts, and as an
introduction to the ways we can manipulate network data through programming. In
particular, this section will serve as a short introduction to the `Mangal`
package to download ecological networks dataset.

We will need a few packages for this (and indeed most of the following) chapter,
which you have installed during the introduction. First, we will want to load
functions to analyse networks themselves:

```julia
using EcologicalNetworks
```

Next, we will load the `Mangal` package, to get access to a variety of functions
allowing us to get network data from the [mangal.io](http://mangal.io) website.
Note that we will not load it with `using`, but with `import` - this means that
we will need to preface the name of the functions by `Mangal.`, to avoid having
a lot of functions with non-specific names in our namespace:

```julia
import Mangal
```

Finally, because we will want to make some visualisations, we will load the
packages for plots:

```julia
using Plots
import EcologicalNetworksPlots
```

All of these packages have documentations, and it is always a good idea to see
the different options available for the various functions. One way to get a
sense of the functions included in a package, or to get help on these functions,
it to type `?[PackageName].` in the Julia REPL, and to press Tab to see the
possible functions. This is also a great way to discover functionalities in
packages.

### Getting the network data

And with this, we are all set to get our first network:

```julia
first_network = Mangal.network(935)
print(first_network.description)
```

This object has information about a network. Most of these information are
metadata, *i.e.* we do not have the actual interactions at this point. We can
get a list of interactions contained in this network with

```julia
first_network_interactions = Mangal.interactions(first_network);
print("There are $(length(first_network_interactions)) interactions in this network")
```

We can have a deeper look at the first interaction:

```julia
first_interaction = first(first_network_interactions)
```

This has *a lot* of information! We can focus on the most important properties:

| Information           | How to get it                   | Result                            |
| --------------------- | ------------------------------- | --------------------------------- |
| Interaction type      | `first_interaction.type`        | `j first_interaction.type`        |
| Species 1             | `first_interaction.from.name`   | `j first_interaction.from.name`   |
| Species 2 taxon ID    | `first_interaction.to.taxon.id` | `j first_interaction.to.taxon.id` |
| Method of observation | `first_interaction.method`      | `j first_interaction.method`      |
| Interaction strength  | `first_interaction.strength`    | `j first_interaction.strength`    |

### Creating the network object

There are a few ways to collect these interactions into a network, but the
simplest by far is to transform (`convert`) our `MangalNetwork` object into a
`UnipartiteQuantitativeNetwork` (which is used by `EcologicalNetworks`) - this
is done as follows:

```julia
N = convert(UnipartiteQuantitativeNetwork, first_network)
```

At this point, you are hopefuly familiar with what "network" means, but may have
some hesitations about the meaning of "unipartite" and "quantitative". **TK**

As a sidenote, we will often adhere to the following convention when naming
networks. `N` is a unipartite network, `B` is a bipartite network, and `R` is a
random network. This is a useful way to get a sense of what we can expect the
variable to contain.

Speaking of which, we know that this network contains information on
pollination, and pollination networks are bipartite, because they have two
groups of organisms (pollinators and polinized), which we assume do not
establish interactions within the group. We can therefore transform (`convert`)
our network into its bipartite representation:

```julia
B = convert(BipartiteQuantitativeNetwork, N)
```

### Visualizing the network

To get a sense of what the network "looks like", we may decide to plot it.

```julia
I = initial(RandomInitialLayout, B)
for step in 1:4000
  position!(ForceDirectedLayout(2.5), I, B)
end
plot(I, B, aspectratio=1)
scatter!(I, B, bipartite=true, mc=:lightgrey, msc=:white, msw=2, ms=8)
```
